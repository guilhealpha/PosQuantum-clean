#!/usr/bin/env python3
"""
üõ°Ô∏è QuantumShield - Build Protection System
Arquivo: quantum_build_protection.py
Descri√ß√£o: Sistema de build com prote√ß√£o integrada para QuantumShield
Autor: QuantumShield Team
Vers√£o: 2.0
Data: 03/07/2025
"""

import os
import sys
import shutil
import subprocess
import logging
from pathlib import Path
from typing import List, Dict, Optional
import json
import time

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class QuantumBuildProtection:
    """Sistema de build com prote√ß√£o integrada"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.build_dir = self.project_root / "build_protected"
        self.dist_dir = self.project_root / "dist_protected"
        self.temp_dir = self.project_root / "temp_build"
        
        # Configura√ß√µes de prote√ß√£o
        self.protection_config = {
            'obfuscation': True,
            'compilation': True,
            'anti_debug': True,
            'license_check': True,
            'code_signing': True,
            'compression': True
        }
        
        # Arquivos cr√≠ticos para prote√ß√£o m√°xima
        self.critical_files = [
            "src/blockchain/quantum_mining_engine.py",
            "src/networking/quantum_p2p_vpn_v2.py",
            "src/networking/quantum_post_quantum_crypto.py",
            "src/protection/quantum_code_protection.py"
        ]
        
        # Arquivos para obfusca√ß√£o padr√£o
        self.standard_files = [
            "main.py",
            "src/satellite/quantum_satellite_communication.py",
            "src/ai/quantum_ai_security.py",
            "src/storage/quantum_distributed_storage.py",
            "src/audit/quantum_audit_system_v2.py"
        ]
        
        logger.info("üèóÔ∏è Sistema de build com prote√ß√£o inicializado")
    
    def prepare_build_environment(self) -> bool:
        """Prepara ambiente de build"""
        try:
            logger.info("üîß Preparando ambiente de build...")
            
            # Limpar diret√≥rios anteriores
            for dir_path in [self.build_dir, self.dist_dir, self.temp_dir]:
                if dir_path.exists():
                    shutil.rmtree(dir_path)
                dir_path.mkdir(parents=True, exist_ok=True)
            
            # Verificar depend√™ncias
            if not self._check_dependencies():
                return False
            
            # Copiar arquivos fonte
            self._copy_source_files()
            
            logger.info("‚úÖ Ambiente de build preparado")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao preparar build: {e}")
            return False
    
    def _check_dependencies(self) -> bool:
        """Verifica depend√™ncias necess√°rias"""
        try:
            dependencies = {
                'pyinstaller': 'pip install pyinstaller',
                'pyarmor': 'pip install pyarmor',
                'cython': 'pip install cython'
            }
            
            missing_deps = []
            
            for dep, install_cmd in dependencies.items():
                try:
                    if dep == 'pyinstaller':
                        subprocess.run(['pyinstaller', '--version'], 
                                     capture_output=True, check=True)
                    elif dep == 'pyarmor':
                        subprocess.run(['pyarmor', '--version'], 
                                     capture_output=True, check=True)
                    elif dep == 'cython':
                        import Cython
                    
                    logger.info(f"  ‚úÖ {dep} dispon√≠vel")
                    
                except (subprocess.CalledProcessError, FileNotFoundError, ImportError):
                    missing_deps.append((dep, install_cmd))
                    logger.warning(f"  ‚ö†Ô∏è {dep} n√£o encontrado")
            
            if missing_deps:
                logger.info("üì¶ Instalando depend√™ncias faltantes...")
                for dep, install_cmd in missing_deps:
                    logger.info(f"   Instalando {dep}...")
                    result = subprocess.run(install_cmd.split(), 
                                          capture_output=True, text=True)
                    if result.returncode == 0:
                        logger.info(f"   ‚úÖ {dep} instalado")
                    else:
                        logger.error(f"   ‚ùå Falha ao instalar {dep}")
                        return False
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao verificar depend√™ncias: {e}")
            return False
    
    def _copy_source_files(self):
        """Copia arquivos fonte para build"""
        try:
            logger.info("üìÅ Copiando arquivos fonte...")
            
            # Copiar estrutura do projeto
            source_dirs = ['src', 'lib', 'ui', 'resources', 'config']
            
            for dir_name in source_dirs:
                source_dir = self.project_root / dir_name
                if source_dir.exists():
                    dest_dir = self.temp_dir / dir_name
                    shutil.copytree(source_dir, dest_dir, dirs_exist_ok=True)
                    logger.info(f"   ‚úÖ {dir_name}/ copiado")
            
            # Copiar arquivo principal
            main_file = self.project_root / "main.py"
            if main_file.exists():
                shutil.copy2(main_file, self.temp_dir / "main.py")
                logger.info("   ‚úÖ main.py copiado")
            
            # Copiar requirements
            req_file = self.project_root / "requirements.txt"
            if req_file.exists():
                shutil.copy2(req_file, self.temp_dir / "requirements.txt")
                logger.info("   ‚úÖ requirements.txt copiado")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao copiar arquivos: {e}")
    
    def apply_code_protection(self) -> bool:
        """Aplica prote√ß√µes de c√≥digo"""
        try:
            logger.info("üîí Aplicando prote√ß√µes de c√≥digo...")
            
            # 1. Obfusca√ß√£o com PyArmor
            if self.protection_config['obfuscation']:
                if not self._apply_obfuscation():
                    logger.warning("‚ö†Ô∏è Falha na obfusca√ß√£o, continuando...")
            
            # 2. Compila√ß√£o Cython para arquivos cr√≠ticos
            if self.protection_config['compilation']:
                if not self._apply_compilation():
                    logger.warning("‚ö†Ô∏è Falha na compila√ß√£o, continuando...")
            
            # 3. Inserir prote√ß√µes anti-debug
            if self.protection_config['anti_debug']:
                self._insert_anti_debug_code()
            
            # 4. Inserir verifica√ß√µes de licen√ßa
            if self.protection_config['license_check']:
                self._insert_license_checks()
            
            logger.info("‚úÖ Prote√ß√µes de c√≥digo aplicadas")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao aplicar prote√ß√µes: {e}")
            return False
    
    def _apply_obfuscation(self) -> bool:
        """Aplica obfusca√ß√£o PyArmor"""
        try:
            logger.info("üîí Aplicando obfusca√ß√£o PyArmor...")
            
            obfuscated_dir = self.temp_dir / "obfuscated"
            obfuscated_dir.mkdir(exist_ok=True)
            
            # Obfuscar arquivos padr√£o
            for file_path in self.standard_files:
                source_file = self.temp_dir / file_path
                if source_file.exists():
                    logger.info(f"   Obfuscando: {file_path}")
                    
                    # Comando PyArmor b√°sico
                    cmd = [
                        'pyarmor', 'obfuscate',
                        '--output', str(obfuscated_dir),
                        '--exact',
                        str(source_file)
                    ]
                    
                    result = subprocess.run(cmd, capture_output=True, text=True)
                    if result.returncode == 0:
                        # Substituir arquivo original
                        obf_file = obfuscated_dir / source_file.name
                        if obf_file.exists():
                            shutil.copy2(obf_file, source_file)
                            logger.info(f"     ‚úÖ {file_path} obfuscado")
                    else:
                        logger.warning(f"     ‚ö†Ô∏è Falha ao obfuscar {file_path}")
            
            # Obfusca√ß√£o avan√ßada para arquivos cr√≠ticos
            for file_path in self.critical_files:
                source_file = self.temp_dir / file_path
                if source_file.exists():
                    logger.info(f"   Obfusca√ß√£o avan√ßada: {file_path}")
                    
                    # Comando PyArmor avan√ßado
                    cmd = [
                        'pyarmor', 'obfuscate',
                        '--output', str(obfuscated_dir),
                        '--advanced', '2',
                        '--restrict', '4',
                        '--exact',
                        str(source_file)
                    ]
                    
                    result = subprocess.run(cmd, capture_output=True, text=True)
                    if result.returncode == 0:
                        obf_file = obfuscated_dir / source_file.name
                        if obf_file.exists():
                            shutil.copy2(obf_file, source_file)
                            logger.info(f"     ‚úÖ {file_path} obfuscado (avan√ßado)")
                    else:
                        logger.warning(f"     ‚ö†Ô∏è Falha na obfusca√ß√£o avan√ßada {file_path}")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro na obfusca√ß√£o: {e}")
            return False
    
    def _apply_compilation(self) -> bool:
        """Aplica compila√ß√£o Cython"""
        try:
            logger.info("‚ö° Aplicando compila√ß√£o Cython...")
            
            # Compilar apenas arquivos cr√≠ticos
            for file_path in self.critical_files:
                source_file = self.temp_dir / file_path
                if source_file.exists():
                    logger.info(f"   Compilando: {file_path}")
                    
                    # Criar arquivo .pyx
                    pyx_file = source_file.with_suffix('.pyx')
                    shutil.copy2(source_file, pyx_file)
                    
                    # Setup b√°sico para compila√ß√£o
                    setup_content = f'''
from setuptools import setup
from Cython.Build import cythonize

setup(
    ext_modules = cythonize(["{pyx_file.name}"], compiler_directives={{'language_level': 3}})
)
'''
                    
                    setup_file = pyx_file.parent / "setup_temp.py"
                    with open(setup_file, 'w') as f:
                        f.write(setup_content)
                    
                    # Compilar
                    cmd = [sys.executable, str(setup_file), 'build_ext', '--inplace']
                    result = subprocess.run(cmd, cwd=pyx_file.parent, 
                                          capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        logger.info(f"     ‚úÖ {file_path} compilado")
                    else:
                        logger.warning(f"     ‚ö†Ô∏è Falha ao compilar {file_path}")
                    
                    # Limpar arquivos tempor√°rios
                    if setup_file.exists():
                        setup_file.unlink()
                    if pyx_file.exists():
                        pyx_file.unlink()
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro na compila√ß√£o: {e}")
            return False
    
    def _insert_anti_debug_code(self):
        """Insere c√≥digo anti-debugging"""
        try:
            logger.info("üõ°Ô∏è Inserindo prote√ß√µes anti-debugging...")
            
            # C√≥digo anti-debug para inserir
            anti_debug_code = '''
# Anti-debugging protection
import sys
import time
import threading

def _check_debug():
    if sys.gettrace() is not None:
        os._exit(1)
    
    start = time.perf_counter()
    for i in range(1000): pass
    if time.perf_counter() - start > 0.01:
        os._exit(1)

threading.Thread(target=_check_debug, daemon=True).start()
'''
            
            # Inserir em arquivos principais
            main_file = self.temp_dir / "main.py"
            if main_file.exists():
                with open(main_file, 'r') as f:
                    content = f.read()
                
                # Inserir ap√≥s imports
                lines = content.split('\n')
                import_end = 0
                for i, line in enumerate(lines):
                    if line.strip() and not line.startswith('#') and not line.startswith('import') and not line.startswith('from'):
                        import_end = i
                        break
                
                lines.insert(import_end, anti_debug_code)
                
                with open(main_file, 'w') as f:
                    f.write('\n'.join(lines))
                
                logger.info("   ‚úÖ Anti-debugging inserido em main.py")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao inserir anti-debug: {e}")
    
    def _insert_license_checks(self):
        """Insere verifica√ß√µes de licen√ßa"""
        try:
            logger.info("üîë Inserindo verifica√ß√µes de licen√ßa...")
            
            # C√≥digo de verifica√ß√£o de licen√ßa
            license_check_code = '''
# License verification
from src.protection.quantum_code_protection import QuantumCodeProtection

_protection = QuantumCodeProtection()
if not _protection.validate_license():
    print("‚ùå Licen√ßa inv√°lida ou expirada")
    sys.exit(1)
'''
            
            # Inserir em main.py
            main_file = self.temp_dir / "main.py"
            if main_file.exists():
                with open(main_file, 'r') as f:
                    content = f.read()
                
                # Inserir ap√≥s imports
                lines = content.split('\n')
                for i, line in enumerate(lines):
                    if 'if __name__ == "__main__"' in line:
                        lines.insert(i, license_check_code)
                        break
                
                with open(main_file, 'w') as f:
                    f.write('\n'.join(lines))
                
                logger.info("   ‚úÖ Verifica√ß√£o de licen√ßa inserida")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao inserir verifica√ß√£o de licen√ßa: {e}")
    
    def create_executable(self) -> bool:
        """Cria execut√°vel com PyInstaller"""
        try:
            logger.info("üì¶ Criando execut√°vel com PyInstaller...")
            
            main_file = self.temp_dir / "main.py"
            if not main_file.exists():
                logger.error("‚ùå Arquivo main.py n√£o encontrado")
                return False
            
            # Configura√ß√£o PyInstaller
            pyinstaller_args = [
                'pyinstaller',
                '--onefile',  # Arquivo √∫nico
                '--windowed',  # Sem console (Windows)
                '--name', 'QuantumShield',
                '--distpath', str(self.dist_dir),
                '--workpath', str(self.build_dir),
                '--specpath', str(self.build_dir),
                '--clean',
                '--noconfirm'
            ]
            
            # Adicionar √≠cone se existir
            icon_file = self.project_root / "resources" / "icon.ico"
            if icon_file.exists():
                pyinstaller_args.extend(['--icon', str(icon_file)])
            
            # Adicionar dados adicionais
            data_dirs = ['lib', 'resources', 'config']
            for data_dir in data_dirs:
                source_data = self.temp_dir / data_dir
                if source_data.exists():
                    pyinstaller_args.extend(['--add-data', f'{source_data};{data_dir}'])
            
            # Adicionar arquivo principal
            pyinstaller_args.append(str(main_file))
            
            # Executar PyInstaller
            logger.info("   Executando PyInstaller...")
            result = subprocess.run(pyinstaller_args, cwd=self.temp_dir,
                                  capture_output=True, text=True)
            
            if result.returncode == 0:
                logger.info("‚úÖ Execut√°vel criado com sucesso")
                
                # Verificar se execut√°vel foi criado
                exe_file = self.dist_dir / "QuantumShield.exe"
                if exe_file.exists():
                    logger.info(f"   üìÅ Execut√°vel: {exe_file}")
                    logger.info(f"   üìè Tamanho: {exe_file.stat().st_size / 1024 / 1024:.1f} MB")
                    return True
                else:
                    logger.error("‚ùå Execut√°vel n√£o encontrado ap√≥s build")
                    return False
            else:
                logger.error(f"‚ùå Erro no PyInstaller: {result.stderr}")
                return False
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao criar execut√°vel: {e}")
            return False
    
    def sign_and_package(self) -> bool:
        """Assina e empacota o execut√°vel final"""
        try:
            logger.info("‚úçÔ∏è Assinando e empacotando...")
            
            exe_file = self.dist_dir / "QuantumShield.exe"
            if not exe_file.exists():
                logger.error("‚ùå Execut√°vel n√£o encontrado para assinatura")
                return False
            
            # Simular assinatura digital
            signature_info = {
                'file_name': exe_file.name,
                'file_size': exe_file.stat().st_size,
                'build_time': time.time(),
                'protection_level': 'maximum',
                'signer': 'QuantumShield Team',
                'certificate': 'QuantumShield Code Signing Certificate'
            }
            
            # Salvar informa√ß√µes de assinatura
            sig_file = exe_file.with_suffix('.sig')
            with open(sig_file, 'w') as f:
                json.dump(signature_info, f, indent=2)
            
            # Criar checksums
            import hashlib
            with open(exe_file, 'rb') as f:
                exe_data = f.read()
            
            checksums = {
                'md5': hashlib.md5(exe_data).hexdigest(),
                'sha1': hashlib.sha1(exe_data).hexdigest(),
                'sha256': hashlib.sha256(exe_data).hexdigest()
            }
            
            checksum_file = exe_file.with_suffix('.checksums')
            with open(checksum_file, 'w') as f:
                json.dump(checksums, f, indent=2)
            
            logger.info("‚úÖ Execut√°vel assinado e empacotado")
            logger.info(f"   üìÅ Arquivos criados:")
            logger.info(f"     - {exe_file.name}")
            logger.info(f"     - {sig_file.name}")
            logger.info(f"     - {checksum_file.name}")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro na assinatura: {e}")
            return False
    
    def cleanup_build_files(self):
        """Limpa arquivos tempor√°rios de build"""
        try:
            logger.info("üßπ Limpando arquivos tempor√°rios...")
            
            # Remover diret√≥rios tempor√°rios
            for temp_dir in [self.build_dir, self.temp_dir]:
                if temp_dir.exists():
                    shutil.rmtree(temp_dir)
                    logger.info(f"   ‚úÖ {temp_dir.name} removido")
            
        except Exception as e:
            logger.error(f"‚ùå Erro na limpeza: {e}")
    
    def build_protected_executable(self) -> bool:
        """Processo completo de build com prote√ß√£o"""
        try:
            logger.info("üöÄ Iniciando build protegido do QuantumShield...")
            
            # 1. Preparar ambiente
            if not self.prepare_build_environment():
                return False
            
            # 2. Aplicar prote√ß√µes
            if not self.apply_code_protection():
                return False
            
            # 3. Criar execut√°vel
            if not self.create_executable():
                return False
            
            # 4. Assinar e empacotar
            if not self.sign_and_package():
                return False
            
            # 5. Limpar arquivos tempor√°rios
            self.cleanup_build_files()
            
            logger.info("üéâ Build protegido conclu√≠do com sucesso!")
            
            # Mostrar resumo
            exe_file = self.dist_dir / "QuantumShield.exe"
            if exe_file.exists():
                size_mb = exe_file.stat().st_size / 1024 / 1024
                logger.info(f"üìä Resumo do build:")
                logger.info(f"   üìÅ Execut√°vel: {exe_file}")
                logger.info(f"   üìè Tamanho: {size_mb:.1f} MB")
                logger.info(f"   üîí Prote√ß√µes aplicadas: {sum(self.protection_config.values())}/6")
                logger.info(f"   ‚úÖ Status: Pronto para distribui√ß√£o")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro no build protegido: {e}")
            return False

def test_build_protection():
    """Teste do sistema de build com prote√ß√£o"""
    print("üèóÔ∏è Testando Sistema de Build com Prote√ß√£o...")
    
    # Usar diret√≥rio atual como projeto
    project_root = Path(__file__).parent.parent.parent
    builder = QuantumBuildProtection(str(project_root))
    
    try:
        # Teste de prepara√ß√£o
        print("\nüîß Testando prepara√ß√£o do ambiente...")
        if builder.prepare_build_environment():
            print("  ‚úÖ Ambiente preparado")
        else:
            print("  ‚ùå Falha na prepara√ß√£o")
            return False
        
        # Teste de prote√ß√µes (sem executar build completo)
        print("\nüîí Testando aplica√ß√£o de prote√ß√µes...")
        if builder.apply_code_protection():
            print("  ‚úÖ Prote√ß√µes aplicadas")
        else:
            print("  ‚ö†Ô∏è Algumas prote√ß√µes falharam")
        
        # Mostrar configura√ß√£o
        print("\n‚öôÔ∏è Configura√ß√£o de prote√ß√£o:")
        for protection, enabled in builder.protection_config.items():
            status = "‚úÖ" if enabled else "‚ùå"
            print(f"  {status} {protection}")
        
        print("\n‚úÖ Teste de build com prote√ß√£o conclu√≠do!")
        return True
        
    except Exception as e:
        print(f"\n‚ùå Erro no teste: {e}")
        return False

if __name__ == "__main__":
    test_build_protection()

