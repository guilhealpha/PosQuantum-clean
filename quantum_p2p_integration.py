#!/usr/bin/env python3
"""
üõ°Ô∏è QuantumShield - P2P Network Integration
Arquivo: quantum_p2p_integration.py
Descri√ß√£o: Integra√ß√£o completa do sistema P2P mesh com DHT, NAT Traversal e VPN
Autor: QuantumShield Team
Vers√£o: 2.0
Data: 03/07/2025
"""

import threading
import time
import logging
import json
import socket
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from pathlib import Path
import hashlib
import secrets

# Importar m√≥dulos QuantumShield P2P
from quantum_dht import QuantumDHT, DHTNode
from quantum_nat_traversal import QuantumNATTraversal, NATMapping
from quantum_p2p_vpn import QuantumP2PVPN, VPNPeer

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class P2PConnection:
    """Conex√£o P2P estabelecida"""
    peer_id: str
    connection_type: str  # direct, hole_punch, relay, vpn
    local_port: int
    remote_ip: str
    remote_port: int
    established_at: float
    last_activity: float
    bytes_sent: int = 0
    bytes_received: int = 0

@dataclass
class P2PService:
    """Servi√ßo P2P anunciado"""
    service_type: str
    service_data: Dict
    port: int
    announced_at: float

class QuantumP2PNetwork:
    """Sistema P2P mesh completo QuantumShield"""
    
    def __init__(self, config: Dict = None):
        self.config = config or self.get_default_config()
        
        # Componentes P2P
        self.dht = QuantumDHT(port=self.config['dht_port'])
        self.nat_traversal = QuantumNATTraversal()
        
        # Inicializar VPN apenas se habilitada
        self.vpn = None
        if self.config.get('enable_vpn', True):
            self.vpn = QuantumP2PVPN(
                vpn_network=self.config.get('vpn_network', '10.42.0.0/24'),
                local_vpn_ip=self.config.get('local_vpn_ip')
            )
        
        # Estado da rede
        self.running = False
        self.node_id = self.dht.node_id
        self.local_ip = self.dht.local_ip
        
        # Conex√µes ativas
        self.connections = {}  # peer_id -> P2PConnection
        self.services = {}     # service_type -> P2PService
        
        # Configura√ß√µes de rede
        self.base_port = self.config['base_port']
        self.port_range = self.config['port_range']
        self.available_ports = list(range(self.base_port, self.base_port + self.port_range))
        
        # Threads de manuten√ß√£o
        self.maintenance_thread = None
        self.discovery_thread = None
        
        # Callbacks
        self.callbacks = {
            'peer_connected': [],
            'peer_disconnected': [],
            'service_discovered': [],
            'message_received': []
        }
        
        # Estat√≠sticas
        self.stats = {
            'network_start_time': 0,
            'peers_discovered': 0,
            'connections_established': 0,
            'services_announced': 0,
            'messages_sent': 0,
            'messages_received': 0,
            'nat_mappings_created': 0,
            'vpn_active': False
        }
        
    def get_default_config(self) -> Dict:
        """Configura√ß√£o padr√£o da rede P2P"""
        return {
            'dht_port': 8888,
            'base_port': 9000,
            'port_range': 100,
            'vpn_network': '10.42.0.0/24',
            'local_vpn_ip': None,
            'enable_vpn': True,
            'enable_nat_traversal': True,
            'discovery_interval': 30,
            'maintenance_interval': 60,
            'connection_timeout': 300,
            'max_connections': 50
        }
    
    def register_callback(self, event_type: str, callback):
        """Registra callback para eventos da rede"""
        if event_type in self.callbacks:
            self.callbacks[event_type].append(callback)
    
    def emit_event(self, event_type: str, data: Any):
        """Emite evento para callbacks registrados"""
        for callback in self.callbacks.get(event_type, []):
            try:
                callback(data)
            except Exception as e:
                logger.error(f"Erro no callback {event_type}: {e}")
    
    def start_network(self) -> bool:
        """Inicia rede P2P completa"""
        try:
            logger.info("üöÄ Iniciando rede P2P QuantumShield...")
            
            self.running = True
            self.stats['network_start_time'] = time.time()
            
            # 1. Iniciar DHT
            logger.info("üì° Iniciando DHT...")
            self.dht.start()
            time.sleep(2)  # Aguardar bootstrap
            
            # 2. Descobrir mapeamentos NAT
            if self.config['enable_nat_traversal']:
                logger.info("üîç Descobrindo mapeamentos NAT...")
                self.discover_nat_mappings()
            
            # 3. Iniciar VPN (se habilitada)
            if self.config['enable_vpn'] and self.vpn:
                logger.info("üõ°Ô∏è Iniciando VPN P2P...")
                if self.vpn.start():
                    self.stats['vpn_active'] = True
                    logger.info("‚úÖ VPN P2P ativa")
                else:
                    logger.warning("‚ö†Ô∏è VPN P2P n√£o p√¥de ser iniciada")
            
            # 4. Iniciar threads de manuten√ß√£o
            self.start_maintenance_threads()
            
            # 5. Anunciar presen√ßa na rede
            self.announce_presence()
            
            logger.info(f"‚úÖ Rede P2P iniciada - Node ID: {self.node_id[:16]}...")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao iniciar rede P2P: {e}")
            return False
    
    def discover_nat_mappings(self):
        """Descobre mapeamentos NAT para portas necess√°rias"""
        try:
            # Descobrir mapeamentos para portas principais
            ports_to_map = [
                self.config['dht_port'],
                self.base_port,
                self.base_port + 1,
                self.base_port + 2
            ]
            
            mappings = self.nat_traversal.discover_multiple_mappings(ports_to_map)
            self.stats['nat_mappings_created'] = len(mappings)
            
            logger.info(f"üîç {len(mappings)} mapeamentos NAT descobertos")
            
        except Exception as e:
            logger.error(f"Erro ao descobrir NAT: {e}")
    
    def start_maintenance_threads(self):
        """Inicia threads de manuten√ß√£o"""
        # Thread de descoberta de peers
        self.discovery_thread = threading.Thread(
            target=self.peer_discovery_loop,
            daemon=True
        )
        self.discovery_thread.start()
        
        # Thread de manuten√ß√£o geral
        self.maintenance_thread = threading.Thread(
            target=self.maintenance_loop,
            daemon=True
        )
        self.maintenance_thread.start()
    
    def announce_presence(self):
        """Anuncia presen√ßa na rede DHT"""
        try:
            # Obter informa√ß√µes de conectividade
            connectivity_info = self.nat_traversal.get_connectivity_info(self.base_port)
            
            # Dados do n√≥
            node_data = {
                'node_id': self.node_id,
                'local_ip': self.local_ip,
                'dht_port': self.config['dht_port'],
                'base_port': self.base_port,
                'capabilities': ['dht', 'nat_traversal', 'vpn', 'blockchain', 'chat'],
                'connectivity': connectivity_info,
                'timestamp': time.time()
            }
            
            if self.stats['vpn_active']:
                node_data['vpn_ip'] = self.vpn.local_vpn_ip if self.vpn else None
            
            # Anunciar na DHT
            self.dht.announce_service('quantumshield_node', node_data)
            
            logger.info("üì¢ Presen√ßa anunciada na rede")
            
        except Exception as e:
            logger.error(f"Erro ao anunciar presen√ßa: {e}")
    
    def peer_discovery_loop(self):
        """Loop de descoberta de peers"""
        while self.running:
            try:
                # Buscar n√≥s QuantumShield na DHT
                nodes = self.dht.find_services('quantumshield_node')
                
                for node_data in nodes:
                    peer_id = node_data.get('node_id')
                    
                    if peer_id and peer_id != self.node_id:
                        if peer_id not in self.connections:
                            # Tentar conectar ao peer
                            self.attempt_peer_connection(node_data)
                
                self.stats['peers_discovered'] = len(nodes)
                
                time.sleep(self.config['discovery_interval'])
                
            except Exception as e:
                logger.error(f"Erro na descoberta de peers: {e}")
                time.sleep(30)
    
    def attempt_peer_connection(self, peer_data: Dict):
        """Tenta conectar a um peer"""
        try:
            peer_id = peer_data['node_id']
            
            logger.info(f"üîó Tentando conectar ao peer: {peer_id[:16]}...")
            
            # Obter informa√ß√µes de conectividade do peer
            connectivity = peer_data.get('connectivity', {})
            peer_ip = connectivity.get('external_ip', peer_data.get('local_ip'))
            peer_port = connectivity.get('external_port', peer_data.get('base_port'))
            
            if not peer_ip or not peer_port:
                logger.warning(f"Informa√ß√µes de conectividade insuficientes para {peer_id[:16]}")
                return
            
            # Tentar estabelecer conex√£o P2P
            connection = self.establish_p2p_connection(peer_id, peer_ip, peer_port, peer_data)
            
            if connection:
                self.connections[peer_id] = connection
                self.stats['connections_established'] += 1
                
                # Emitir evento
                self.emit_event('peer_connected', {
                    'peer_id': peer_id,
                    'connection': connection
                })
                
                logger.info(f"‚úÖ Conectado ao peer: {peer_id[:16]} via {connection.connection_type}")
                
                # Se VPN ativa, adicionar peer √† VPN
                if self.stats['vpn_active'] and 'vpn_ip' in peer_data:
                    self.add_peer_to_vpn(peer_id, peer_data)
            
        except Exception as e:
            logger.error(f"Erro ao conectar ao peer: {e}")
    
    def establish_p2p_connection(self, peer_id: str, peer_ip: str, peer_port: int, peer_data: Dict) -> Optional[P2PConnection]:
        """Estabelece conex√£o P2P com peer"""
        try:
            local_port = self.get_available_port()
            if not local_port:
                return None
            
            # M√©todo 1: Conex√£o direta
            if self.test_direct_connection(peer_ip, peer_port):
                return P2PConnection(
                    peer_id=peer_id,
                    connection_type='direct',
                    local_port=local_port,
                    remote_ip=peer_ip,
                    remote_port=peer_port,
                    established_at=time.time(),
                    last_activity=time.time()
                )
            
            # M√©todo 2: Hole punching
            if self.nat_traversal.create_hole_punch(local_port, peer_ip, peer_port):
                return P2PConnection(
                    peer_id=peer_id,
                    connection_type='hole_punch',
                    local_port=local_port,
                    remote_ip=peer_ip,
                    remote_port=peer_port,
                    established_at=time.time(),
                    last_activity=time.time()
                )
            
            # M√©todo 3: Relay TURN
            connectivity = peer_data.get('connectivity', {})
            relays = connectivity.get('relays', [])
            
            for relay in relays:
                session_id = self.nat_traversal.connect_via_relay(
                    relay['ip'], relay['port'], peer_ip, peer_port
                )
                if session_id:
                    return P2PConnection(
                        peer_id=peer_id,
                        connection_type='relay',
                        local_port=local_port,
                        remote_ip=relay['ip'],
                        remote_port=relay['port'],
                        established_at=time.time(),
                        last_activity=time.time()
                    )
            
            return None
            
        except Exception as e:
            logger.error(f"Erro ao estabelecer conex√£o P2P: {e}")
            return None
    
    def test_direct_connection(self, ip: str, port: int) -> bool:
        """Testa conectividade direta com peer"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(2.0)
            
            test_data = b"QUANTUM_P2P_TEST"
            sock.sendto(test_data, (ip, port))
            
            response, addr = sock.recvfrom(1024)
            sock.close()
            
            return response == b"QUANTUM_P2P_ACK"
            
        except (socket.timeout, socket.error):
            return False
    
    def add_peer_to_vpn(self, peer_id: str, peer_data: Dict):
        """Adiciona peer √† VPN"""
        try:
            if not self.vpn or 'vpn_ip' not in peer_data:
                return
            
            # Gerar chave p√∫blica simulada (em produ√ß√£o, usar troca de chaves real)
            peer_public_key = hashlib.sha256(peer_id.encode()).digest()
            
            connectivity = peer_data.get('connectivity', {})
            external_ip = connectivity.get('external_ip', peer_data.get('local_ip'))
            external_port = connectivity.get('external_port', peer_data.get('base_port'))
            
            self.vpn.add_peer(
                peer_id=peer_id,
                peer_public_key=peer_public_key,
                external_ip=external_ip,
                external_port=external_port + 1,  # Porta VPN
                vpn_ip=peer_data['vpn_ip']
            )
            
            logger.info(f"üõ°Ô∏è Peer adicionado √† VPN: {peer_id[:16]} ({peer_data['vpn_ip']})")
            
        except Exception as e:
            logger.error(f"Erro ao adicionar peer √† VPN: {e}")
    
    def get_available_port(self) -> Optional[int]:
        """Obt√©m porta dispon√≠vel"""
        if self.available_ports:
            return self.available_ports.pop(0)
        return None
    
    def maintenance_loop(self):
        """Loop de manuten√ß√£o da rede"""
        while self.running:
            try:
                current_time = time.time()
                
                # Verificar conex√µes inativas
                inactive_peers = []
                for peer_id, connection in self.connections.items():
                    if current_time - connection.last_activity > self.config['connection_timeout']:
                        inactive_peers.append(peer_id)
                
                # Remover conex√µes inativas
                for peer_id in inactive_peers:
                    self.disconnect_peer(peer_id)
                
                # Re-anunciar presen√ßa periodicamente
                if int(current_time) % 300 == 0:  # A cada 5 minutos
                    self.announce_presence()
                
                # Limitar n√∫mero de conex√µes
                if len(self.connections) > self.config['max_connections']:
                    # Remover conex√µes mais antigas
                    oldest_peers = sorted(
                        self.connections.items(),
                        key=lambda x: x[1].last_activity
                    )
                    
                    for peer_id, _ in oldest_peers[:len(self.connections) - self.config['max_connections']]:
                        self.disconnect_peer(peer_id)
                
                time.sleep(self.config['maintenance_interval'])
                
            except Exception as e:
                logger.error(f"Erro na manuten√ß√£o: {e}")
                time.sleep(60)
    
    def disconnect_peer(self, peer_id: str):
        """Desconecta peer"""
        try:
            if peer_id in self.connections:
                connection = self.connections[peer_id]
                
                # Liberar porta
                self.available_ports.append(connection.local_port)
                
                # Remover da lista de conex√µes
                del self.connections[peer_id]
                
                # Emitir evento
                self.emit_event('peer_disconnected', {
                    'peer_id': peer_id,
                    'connection': connection
                })
                
                logger.info(f"üîå Peer desconectado: {peer_id[:16]}")
            
        except Exception as e:
            logger.error(f"Erro ao desconectar peer: {e}")
    
    def announce_service(self, service_type: str, service_data: Dict, port: int = None):
        """Anuncia servi√ßo na rede"""
        try:
            if port is None:
                port = self.get_available_port()
                if not port:
                    logger.error("Nenhuma porta dispon√≠vel para servi√ßo")
                    return False
            
            # Criar servi√ßo
            service = P2PService(
                service_type=service_type,
                service_data=service_data,
                port=port,
                announced_at=time.time()
            )
            
            self.services[service_type] = service
            
            # Anunciar na DHT
            announcement_data = {
                'node_id': self.node_id,
                'service_type': service_type,
                'service_data': service_data,
                'port': port,
                'timestamp': time.time()
            }
            
            self.dht.announce_service(f"service_{service_type}", announcement_data)
            
            self.stats['services_announced'] += 1
            logger.info(f"üì¢ Servi√ßo anunciado: {service_type} (porta {port})")
            
            return True
            
        except Exception as e:
            logger.error(f"Erro ao anunciar servi√ßo: {e}")
            return False
    
    def discover_services(self, service_type: str) -> List[Dict]:
        """Descobre servi√ßos na rede"""
        try:
            services = self.dht.find_services(f"service_{service_type}")
            
            # Filtrar servi√ßos pr√≥prios
            filtered_services = []
            for service in services:
                if service.get('node_id') != self.node_id:
                    filtered_services.append(service)
            
            return filtered_services
            
        except Exception as e:
            logger.error(f"Erro ao descobrir servi√ßos: {e}")
            return []
    
    def send_message(self, peer_id: str, message_type: str, data: Dict) -> bool:
        """Envia mensagem para peer"""
        try:
            if peer_id not in self.connections:
                logger.warning(f"Peer n√£o conectado: {peer_id[:16]}")
                return False
            
            connection = self.connections[peer_id]
            
            # Criar mensagem
            message = {
                'type': message_type,
                'from': self.node_id,
                'to': peer_id,
                'data': data,
                'timestamp': time.time()
            }
            
            message_data = json.dumps(message).encode('utf-8')
            
            # Enviar via socket UDP
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.sendto(message_data, (connection.remote_ip, connection.remote_port))
            sock.close()
            
            # Atualizar estat√≠sticas
            connection.bytes_sent += len(message_data)
            connection.last_activity = time.time()
            self.stats['messages_sent'] += 1
            
            return True
            
        except Exception as e:
            logger.error(f"Erro ao enviar mensagem: {e}")
            return False
    
    def broadcast_message(self, message_type: str, data: Dict):
        """Envia mensagem para todos os peers"""
        for peer_id in self.connections:
            self.send_message(peer_id, message_type, data)
    
    def stop_network(self):
        """Para rede P2P"""
        try:
            logger.info("üõë Parando rede P2P...")
            
            self.running = False
            
            # Parar VPN
            if self.stats['vpn_active'] and self.vpn:
                self.vpn.stop()
            
            # Parar DHT
            self.dht.stop()
            
            # Desconectar todos os peers
            for peer_id in list(self.connections.keys()):
                self.disconnect_peer(peer_id)
            
            logger.info("‚úÖ Rede P2P parada")
            
        except Exception as e:
            logger.error(f"Erro ao parar rede: {e}")
    
    def get_network_stats(self) -> Dict:
        """Obt√©m estat√≠sticas da rede"""
        uptime = time.time() - self.stats['network_start_time'] if self.stats['network_start_time'] else 0
        
        # Combinar estat√≠sticas de todos os componentes
        dht_stats = self.dht.get_stats()
        nat_stats = self.nat_traversal.get_stats()
        vpn_stats = self.vpn.get_stats() if self.vpn and self.stats['vpn_active'] else {}
        
        return {
            'network_uptime': int(uptime),
            'node_id': self.node_id[:16] + "...",
            'local_ip': self.local_ip,
            'running': self.running,
            'connections_active': len(self.connections),
            'services_announced': len(self.services),
            'dht': dht_stats,
            'nat_traversal': nat_stats,
            'vpn': vpn_stats,
            'general': self.stats
        }
    
    def get_peer_list(self) -> List[Dict]:
        """Obt√©m lista de peers conectados"""
        peer_list = []
        
        for peer_id, connection in self.connections.items():
            peer_info = {
                'peer_id': peer_id[:16] + "...",
                'connection_type': connection.connection_type,
                'remote_ip': connection.remote_ip,
                'remote_port': connection.remote_port,
                'connected_since': connection.established_at,
                'last_activity': connection.last_activity,
                'bytes_sent': connection.bytes_sent,
                'bytes_received': connection.bytes_received
            }
            peer_list.append(peer_info)
        
        return peer_list

def test_p2p_integration():
    """Teste da integra√ß√£o P2P completa"""
    print("üõ°Ô∏è Testando Integra√ß√£o P2P QuantumShield...")
    
    # Configura√ß√£o de teste
    config = {
        'dht_port': 8890,
        'base_port': 9100,
        'port_range': 10,
        'enable_vpn': False,  # Desabilitar VPN para teste
        'enable_nat_traversal': True,
        'discovery_interval': 5,
        'maintenance_interval': 10
    }
    
    network = QuantumP2PNetwork(config)
    
    try:
        # Registrar callbacks de teste
        def on_peer_connected(data):
            print(f"‚úÖ Peer conectado: {data['peer_id'][:16]}...")
        
        def on_peer_disconnected(data):
            print(f"üîå Peer desconectado: {data['peer_id'][:16]}...")
        
        network.register_callback('peer_connected', on_peer_connected)
        network.register_callback('peer_disconnected', on_peer_disconnected)
        
        # Iniciar rede
        print("\nüöÄ Iniciando rede P2P...")
        if network.start_network():
            print("‚úÖ Rede P2P iniciada")
            
            # Aguardar um pouco para descoberta
            time.sleep(5)
            
            # Anunciar servi√ßo de teste
            print("\nüì¢ Anunciando servi√ßo...")
            network.announce_service('test_service', {
                'description': 'Servi√ßo de teste QuantumShield',
                'version': '2.0'
            })
            
            # Descobrir servi√ßos
            print("\nüîç Descobrindo servi√ßos...")
            services = network.discover_services('test_service')
            print(f"‚úÖ {len(services)} servi√ßos descobertos")
            
            # Aguardar mais um pouco
            time.sleep(3)
            
            # Verificar estat√≠sticas
            print("\nüìä Estat√≠sticas da rede:")
            stats = network.get_network_stats()
            
            print(f"  Node ID: {stats['node_id']}")
            print(f"  Uptime: {stats['network_uptime']}s")
            print(f"  Conex√µes ativas: {stats['connections_active']}")
            print(f"  Servi√ßos anunciados: {stats['services_announced']}")
            print(f"  DHT - N√≥s descobertos: {stats['dht']['nodes_discovered']}")
            print(f"  NAT - Taxa de sucesso: {stats['nat_traversal']['success_rate']:.1f}%")
            
            # Listar peers
            peers = network.get_peer_list()
            print(f"\nüë• Peers conectados: {len(peers)}")
            for peer in peers:
                print(f"  {peer['peer_id']} via {peer['connection_type']}")
            
            # Parar rede
            network.stop_network()
            print("\n‚úÖ Teste de integra√ß√£o P2P conclu√≠do")
            
            return True
            
        else:
            print("‚ùå Falha ao iniciar rede P2P")
            return False
            
    except Exception as e:
        print(f"‚ùå Erro no teste: {e}")
        return False

if __name__ == "__main__":
    test_p2p_integration()

